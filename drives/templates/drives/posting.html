<!-- https://developers.google.com/maps/documentation/directions/intro#DirectionsResponses -->
{% extends 'RideOn/base.html' %}

{% block title %} Ride Posting {% endblock %}

{% block content %}
    <div class="container">
        <h1>{{drive.title}}</h1>
		{% if drive.status == "Cancelled" %}
			<div class="row">
				<div class="col-6">
					<h3 class="text-danger"> Drive Cancelled </h3>
				</div>
			</div>
		{%  elif drive.status == "Completed" %}
			<div class="col-6">
				<div class="row">
					<h3 class="text-success"> Drive Completed </h3>
				</div>
			</div>
		{% endif %}
		
        <div class="row">
            <div class="col-6">
                <p>Route {{drive.start_location}} {{drive.end_location}}</p>
                <div id="map" style="height: 25vw; width: 100%;"></div>
                <div id="startx" style="display: none;">{{drive.start_location.coordinates_x}}</div>
                <div id="starty" style="display: none;">{{drive.start_location.coordinates_y}}</div>
                <div id="endx" style="display: none;">{{drive.end_location.coordinates_x}}</div>
                <div id="endy" style="display: none;">{{drive.end_location.coordinates_y}}</div>
                <div id="travel_time" style="display: none;">{{drive.time}}</div>
                <script>

					function getWaypoints() {
						var requestWaypoints = document.getElementsByClassName("waypointData");
						
						var waypoints = [];
						
						for (var i=0; i < requestWaypoints.length; i++) {
							var parameters = requestWaypoints[i].value.split(":");
							console.log(parameters);
							var lng = parseFloat(parameters[0]);
							var lat = parseFloat(parameters[1]);
							waypoints.push( {
								location:new google.maps.LatLng(lat, lng),
								stopover:true
							});
						}
						
						return waypoints;
					}
					
					function getRequestWaypoints() {
						var requestWaypoints = document.getElementsByClassName("requestWaypointData");
						
						var waypoints = [];
						
						for (var i=0; i < requestWaypoints.length; i++) {
							var parameters = requestWaypoints[i].value.split(":");
							console.log(parameters);
							var lng = parseFloat(parameters[0]);
							var lat = parseFloat(parameters[1]);
							waypoints.push( {
								location:new google.maps.LatLng(lat, lng),
								stopover:true
							});
						}
						return waypoints;
					}
					
                    function initMap() {
                        var start_coordinates = { lat: parseFloat(document.getElementById('starty').innerText), lng: parseFloat(document.getElementById('startx').innerText) };
                        var end_coordinates = { lat: parseFloat(document.getElementById('endy').innerText), lng: parseFloat(document.getElementById('endx').innerText) };

                        var map = new google.maps.Map(document.getElementById('map'), {
                            zoom: 10,
                            center: start_coordinates
                        });

                        var marker_start = new google.maps.Marker({
                            position: start_coordinates,
                            map: map,
                            title: 'To Be Improved'
                        });

                        var marker_end = new google.maps.Marker({
                            position: end_coordinates,
                            map: map,
                            title: 'To Be Improved'
                        });

                        var directionsDisplay = new google.maps.DirectionsRenderer();
                        var directionsService = new google.maps.DirectionsService();

                        directionsDisplay.setMap(map)
                        // can also add waypoints here
                        // can also add duration information if add the travel time. but it sounds boring atm.
                        var request = {
                            origin: start_coordinates,
							waypoints: getWaypoints(),
                            destination: end_coordinates,
                            travelMode: 'DRIVING'
                        };

                        directionsService.route(request, function(result, status){
                            if (status == "OK"){
                                directionsDisplay.setDirections(result);
                            }
                        });
                        
                    }
					
					$(document).ready(function(){
						$( "#viewWaypointModal" ).on('shown.bs.modal', function(){
							initialize_direction();
						});
					});
					
					$(document).ready(function(){
						$( "#addWaypointModal" ).on('shown.bs.modal', function(){
							initAutocompleteNew();
						});
					});
					
					$(document).ready(function(){
						$( "#editWaypointModal" ).on('shown.bs.modal', function(){
							initAutocompleteEdit();
						});
					});
					
					function initialize_direction() {
						var directionDisplay;
						var directionsService = new google.maps.DirectionsService();
						var direction_map;

						directionDisplay = new google.maps.DirectionsRenderer();
						var myOptions = {
							mapTypeId: google.maps.MapTypeId.ROADMAP,
						}
						direction_map = new google.maps.Map(document.getElementById("map2"), myOptions);
						directionDisplay.setMap(direction_map);

						var start_coordinates = { lat: parseFloat(document.getElementById('starty').innerText), lng: parseFloat(document.getElementById('startx').innerText) };
                        var end_coordinates = { lat: parseFloat(document.getElementById('endy').innerText), lng: parseFloat(document.getElementById('endx').innerText) };
						
						waypointList = getWaypoints();
						waypointList.push.apply(waypointList, getRequestWaypoints());
						var request = {
							origin:start_coordinates,
							waypoints: waypointList,
							destination:end_coordinates,
							travelMode: google.maps.DirectionsTravelMode.DRIVING
						};
						directionsService.route(request, function(response, status) {
							if (status == google.maps.DirectionsStatus.OK) {
								directionDisplay.setDirections(response);
							}
						});
						
					}
					
					function initAutocompleteNew() {
						// Create the autocomplete object, restricting the search predictions to
						// geographical location types.
						autocomplete_new = new google.maps.places.Autocomplete(
							document.getElementById('autocomplete_waypoint_new'), { types: ['geocode'] });

						// Avoid paying for data that you don't need by restricting the set of
						// place fields that are returned to just the address components.
						autocomplete_new.setFields(['address_component', 'geometry']);

						// When the user selects an address from the drop-down, populate the
						// address fields in the form.
						autocomplete_new.addListener('place_changed', fillInAddress_waypoint_new);
					}

					function fillInAddress_waypoint_new() {
						// Get the place details from the autocomplete object.
						var place = autocomplete_new.getPlace();

						document.getElementById("autocomplete_location_x").value = place.geometry.location.lng();
						document.getElementById("autocomplete_location_y").value = place.geometry.location.lat();
						document.getElementById("autocomplete_location").value = document.getElementById("autocomplete_waypoint_new").value;
					}

					// Bias the autocomplete object to the user's geographical location,
					// as supplied by the browser's 'navigator.geolocation' object.
					function geolocate_waypoint_new() {
						if (navigator.geolocation) {
							navigator.geolocation.getCurrentPosition(function (position) {
								var geolocation = {
									lat: position.coords.latitude,
									lng: position.coords.longitude
								};
								var circle = new google.maps.Circle(
									{ center: geolocation, radius: position.coords.accuracy });
								autocomplete_new.setBounds(circle.getBounds());
							});
						}
					}
			
					function initAutocompleteEdit() {
						// Create the autocomplete object, restricting the search predictions to
						// geographical location types.
						autocomplete_edit = new google.maps.places.Autocomplete(
							document.getElementById('autocomplete_waypoint_edit'), { types: ['geocode'] });

						// Avoid paying for data that you don't need by restricting the set of
						// place fields that are returned to just the address components.
						autocomplete_edit.setFields(['address_component', 'geometry']);

						// When the user selects an address from the drop-down, populate the
						// address fields in the form.
						autocomplete_edit.addListener('place_changed', fillInAddress_waypoint_edit);
					}

					function fillInAddress_waypoint_edit() {
						// Get the place details from the autocomplete object.
						var place = autocomplete_edit.getPlace();

						document.getElementById("autocomplete_location_x").value = place.geometry.location.lng();
						document.getElementById("autocomplete_location_y").value = place.geometry.location.lat();
						document.getElementById("autocomplete_location").value = document.getElementById("autocomplete_waypoint_edit").value;
					}

					// Bias the autocomplete object to the user's geographical location,
					// as supplied by the browser's 'navigator.geolocation' object.
					function geolocate_waypoint_edit() {
						if (navigator.geolocation) {
							navigator.geolocation.getCurrentPosition(function (position) {
								var geolocation = {
									lat: position.coords.latitude,
									lng: position.coords.longitude
								};
								var circle = new google.maps.Circle(
									{ center: geolocation, radius: position.coords.accuracy });
								autocomplete_edit.setBounds(circle.getBounds());
							});
						}
					}
                </script>
                <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDY7BlSzTYJKwTNrObrU7so714CJgF3Uhc&libraries=places&callback=initMap">
                </script>

				<!-- Show the passenger edit templat if the driver is viewing this -->
				<!-- Otherwise just show a list of passengers -->
				{% if user.username == drive.driver.username %}
					<div class="basic">
						{% include "drives/passenger_templates/passenger_edit.html" %}    
					</div>
				{% else %}
					<div class="basic">
						{% include "drives/passenger_templates/passenger_list.html" %}    
					</div>
				{% endif %}
            </div>
            <div class="col-6">
				{% if drive.driver.id == user.id and drive.status == "Listed" %}
					<div class="col-2">
						<button class="btn btn-default" onclick="window.location.href = '/drives/{{ drive.id }}/edit/';">Edit Drive</button>
					</div>
					<div>
						<form method="post" action="drive_cancel" id="drive_cancel_form">
							{% csrf_token %}
							<button type="submit" class="btn btn-outline-danger btn-sm float-right" id="drive_cancel_btn">Cancel Ride</button>
						</form>
						<form method="post" action="drive_complete" id="drive_complete_form">
							{% csrf_token %}
							<button type="submit" class="btn btn-outline-success btn-sm float-right" id="drive_cancel_btn">Complete Ride</button>
						</form>
					</div>
				{% endif %}
                <p>Driver: <a href="{% url 'users:profile' drive.driver.id %}">{{ drive.driver.username }}</a></p>
                <p>Date: {{drive.date_time}}</p>
                <p>Cost: {{drive.min_cost}}$ - {{drive.max_cost}}$</p>
                <p>Payment: {{drive.payment_method}}</p>
                <p>Max Passengers: {{drive.max_passengers}}</p>
                <p>Vehicle: {{drive.car_description}}</p>
                <p>Luggage Capacity: {{drive.luggage_description}}</p>
                <p>Description: {{drive.description}}</p>
                <p>Location: {{drive.start_location.coordinates_x}}</p>

            </div>
        </div>
    </div>
	
	<!-- Load waypoint data into hidden elements so JavaScript can access it -->
	{% for request in drive.requestList.all %}
		<input type="hidden" class="requestWaypointData" value="{{ request.waypoint.coordinates_x }}:{{ request.waypoint.coordinates_y }}:{{ request.waypoint.location }}" >
	{% endfor %}
	{% for waypoint in drive.waypointList.all %}
		<input type="hidden" class="waypointData" value="{{ waypoint.coordinates_x }}:{{ waypoint.coordinates_y }}:{{ waypoint.location }}" >
	{% endfor %}

	</div>

{% endblock %}